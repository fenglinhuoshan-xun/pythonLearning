"""
    封装 -- 私有成员
        障眼法：修改了私有变量名称
            本质：看似是__变量名，实则是_类名__变量名
            只有在类的内部用对象创建变量用了__，才叫私有变量
            在类外用对象创建变量用了__，实则是创建了实例变量
"""


# 我们怎么实现对数据的保护
# 1. 私有化实例变量
# 2. 提供两个公开的读写方法
# 这一招是我们在其他语言中常采用的策略，在python中其实不是这个习惯，在python中怎么做？下节再说


class Wife:
    def __init__(self, name="", age=0):
        self.name = name
        # 变量前面加上两个下划线，这就是python中将变量变成私有成员的一个语法。一旦加了两个下划线，就变成私有变量了，类外不能访问
        # 做成私有成员的目的：就是让类的外面不要去访问我。潜台词就是保护了这个数据
        # self.__age = age
        # 不使用上面的方式来访问私有成员，通过调用方法来访问私有成员
        self.set_age(age)

    # 但是光藏起来是不够的，因为外界需要给它赋值，外界需要有需求去读取它
    # 所以我们保护起来之后，再提供两个公开的方法，一个需要对私有成员进行返回，另一个需要对私有成员进行有效性的验证
    def get_age(self):
        return self.__age

    def set_age(self, value):
        if 20 <= value <= 50:
            self.__age = value  # 创建了私有变量，看似是__age，实则是_Wife__age
        else:
            raise Exception("我不要")


# 如果就这么封装数据的话，从行为角度上讲还是有所欠缺的
# 如果我们把这个数据就这么无情的暴露出去了，那么对于外界，我们就可以无情的往里面赋值
# 所以我们应该把实际存储数据的变量给藏起来
w01 = Wife("宁宁", 25)
w02 = Wife("铁锤", 260)

# 障眼法，其实也是可以访问到的
w01.__age = 100  # 创建了实例变量
print(w01.__age) # 私有化了：在类的内部可以访问到，外部就访问不到了
print(w01.__dict__)  # {'name': '宁宁', '_Wife__age': 25, '__age': 100}
print(w02.__dict__)  # {'name': '铁锤', '_Wife__age': 26}
print(w01._Wife__age) # 了解本质之后，可以这样访问私有变量，但是特别不建议这样子访问。好比人家女生穿了衣服，你非要脱了往肉里看

# w01.set_age(27)
# print(w01.get_age())
